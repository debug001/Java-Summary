#散列表
##符号表
将一个键和一个值联系起来的结构
##概述
如果所有的键都是比较小的整数,那么我们可以使用数组来实现符号表这种键值结构.

将数组的索引作为键,索引对应的数组值就是键对应的值.

如果键是其他类型就需要做一些处理来解决这种对应关系,这就是散列查找算法.

散列的查找算法分为两步:
- **用散列函数将被查找的键转化为数组的一个索引**
- **处理碰撞冲突(因为在第一步中,我们会遇到两个或者是多个键会散列到相同的数组索引的情况)**

解决碰撞冲突的两种方法:
- **拉链法**
- **线性探测法**

##散列函数
散列函数的计算,这个过程会将键转化为数组的索引.例如如果我们有一个保存M个键值对的数组,

那么就需要一个能够将任意键转化为该数组范围的索引([0,M-1]内的整数)的散列函数.

我们要找的散列函数应该易于计算并且能够均匀分布所有的键,即对于任意键,0~M-1之间的每个整数都有可能与之对应.

###1.正整数
将正整数散列的最常用的方法时**除留余数法**,我们选择大小为**素数**M的数组,对于任意正整数k,计算k除以M的余数.

因为M是素数,所以散列值会很均匀.
<table>
    <tr>
      <td>键</td>
      <td>212</td>
      <td>618</td>
      <td>302</td>
      <td>940</td>
      <td>702</td>
      <td>704</td>
    </tr>
    <tr>
      <td>散列值M=97</td>
      <td>18</td>
      <td>36</td>
      <td>11</td>
      <td>67</td>
      <td>23</td>
      <td>25</td>
    </tr>
    <tr>
      <td>散列值M=100</td>
      <td>12</td>
      <td>18</td>
      <td>2</td>
      <td>40</td>
      <td>2</td>
      <td>4</td>
    </tr>
</table>
###2.浮点数
如果是0~1之间的实数,我们可以将它乘以M并四舍五入得到一个0到M-1之间的索引值.尽管这个方法很容易理解.

但是它是有缺陷的:就是浮点数的高位气的作用更大,而浮点数的低位对散列的结果基本没有影响,这点不难理解,会造成严重的碰撞冲突.

Java中的做法是将浮点数表示为二级制再使用除留余数法.
###3.字符串
字符串也可以使用除留余数法处理:
```java
  String s="Hello World";
  int hash=0;
  for(int i=0;i<s.length;i++){
    hash=(31*hash+s.charAt(i))%M;
  }
```
Java的String的默认实现用了类似的方法.
###4.Java的约定
每种数据类型都需要响应的散列函数,于是Java令所有的数据类型都继承了一个hashCode()方法,每一种数据类型的hashCode()方法都必须

和equals()方法一致,如果a.equals(b)返回true,则a.hashCode()必然等于b.hashCode(),但是a.hashCode==b.hashCode(),a也不一定与b相同.

请注意:在Java中,如果你要为自定义的数据类型定义散列函数,你需要同时重写hashCode()和equals()两个方法.
###5.自定义的数据类型定义散列函数
简单的实现:
```java
public class Student{
  String name;
  int age;
  String school;
  public Student(){}
  public Student(String name,int age,String school){
    this.name=name;
    this.age=age;
    this.school=school;
  }
  @Override
  public boolean equals(Object o){
    if(o==null)
      return false;
    if(o==this)
      return true;
    if(o instanceof Student){
      Student s=(Student) o;
      return (s.name.equals(name)&&s.school.equals(school)&&s.age==age);
    }
    return false;
  }
  @Override
  public int hashCode(){
    int hash=7;
    hash=31*hash+name.hashCode();
    hash=31*hash+((Integer) age).hashCode();
    hash=31*hash+school.hashCode();
    return hash;
  }
}
```
##基于拉链法的散列表
