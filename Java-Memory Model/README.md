#Java内存模型
##目标
Java内存模型的目的是屏蔽各种硬件和操作系统的内存访问差异(c/c++是直接使用机器的物理硬件和操作系统).
##主内存与工作内存
Java内存模型中规定了所有的变量都存储在主内存中,每条线程还有自己的工作内存.

线程的工作内存中保存了该线程使用到的变量是主内存对应变量的拷贝,线程对变量的所有操作(读取,赋值)都必须在工作内存中进行,而不能直接读写主内存中的变量.

不同线程之间无法直接访问对方工作内存中的变量,线程间变量值的传递均需要在主内存来完成.
##主内存和工作内存之间的操作
关于主内存与工作内存之间的具体交互协议,即一个变量如何从主内存拷贝到工作内存,

如何从工作内存同步到主内存之间的实现细节,Java内存模型定义了以下八种操作来完成.
- lock(锁定):作用于主内存的变量,把一个变量标识为一条线程独占状态.
- unlock(解锁):与lock的作用相反.
- read(读取):作用于主内存的变量,把一个变量值从主内存传输到线程的工作内存中,以便随后的load动作使用.
- load(载入):作用于工作内存的变量,把read操作从主内存中得到的变量值放入到工作内存的变量副本中.
- use(使用):作用于工作内存的变量,把工作内存中的一个变量值传递给执行引擎.
- assign(赋值):作用于工作内存中的变量,它把一个从执行引擎接收到的值赋值给工作内存的变量.
- store(存储):作用于工作内存中的变量,它把工作内存中的变量值传送到主内存中,以便随后的write操作.
- write(写入):作用于主内存中的变量,把store操作得到的值赋予主内存对应的变量上.

###遵循的规则
**如果要把一个变量从主内存中复制到工作内存,就需要按顺寻地执行read和load操作**;

**如果把变量从工作内存中同步回主内存中.就要按顺序地执行store和write操作**.

Java内存模型只要求上述操作必须按顺序执行,而没有保证必须是连续执行.也就是read和load之间,store和write之间是可以插入其他指令的.

一个新的变量只能在主内存中诞生.

一个变量在同一时刻只允许一条线程对其进行lock操作,lock和unlock必须成对出现.
##volatile变量
最轻量级的同步机制(并不能保证原子性)

特征:
- 可见性.当一个线程修改了volatile变量的值时.改变后的值对于其他线程来说是立刻得知的(普通变量需要经过read,load操作).
- 禁止指令重排序优化.
##内存模型的三个特性
- 原子性:基本的数据读写操作是具备原子性的.
- 可见性:变量修改后将新值同步回主内存,在读取前从主内存中得到最新的变量值.
- 有序性.
